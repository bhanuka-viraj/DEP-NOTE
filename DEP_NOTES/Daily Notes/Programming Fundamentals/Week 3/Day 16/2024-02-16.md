|                                                | How compiler take the decision to evoke the method in overloading                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| What is static<br>dispatching                  | determine the which method or function to invoke at compile time. (in overload methods)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| How static dispatching works                   | (1)Compile Time step 1 - Determine type to search<br><br>The first step in processing a method invocation at compile time is to figure out the name of the method to be invoked and ==which type to search for definitions of methods of that name.==<br><br>meaning of the highlighted part -> evalaute the data type of the arguments.<br><br>(2)Compile Time step 2 - Determine the method signature<br><br>The second step searches the type determined in the previous step for member methods. This step uses the name of the method and the argument expressions to locate methods that are both ==_accessible_ and _applicable_==, that is, declarations that can be correctly invoked on the given arguments. <br><br> |
| how to determine whether applicable <br>or not | There are three steps to determine whether applicable.<br>1. Try to find methods without boxing and unboxing -> fixed arity<br>2.Try to find methods using boxing and unboxing -> fixed arity<br>3.Try to find methods using variable arity method -> variable arity<br><br>in a one method if it is not found a at least one method they go for the next step.<br><br>if there is no method found, then compile time error occurred.                                                                                                                                                                                                                                                                                           |
| ==What is a arity method==                     | If there is a atleast one paramter. It is called arity methods.<br><br>There are two arity methods. <br>Fixed arity methods and variable arity methods.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| What is fixed arity method                     | If a methods can be passed fixed amount of arguments it is called fixed arity                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| What is variable arity methods                 | if a method can be passed non fixed amount of arguments (var args) it is called variable arity method                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Strict Invocation<br>(first phase)             | Performs overload resolution ==without permitting boxing or unboxing conversion.== If no applicable method is found during this phase then processing continues to the second phase.<br><br>==conversions that are used in this phase =>==<br><br>identity conversion<br>Widening primitive conversion<br>Widening reference conversion<br>                                                                                                                                                                                                                                                                                                                                                                                     |
| Loose Invocation<br>(second phase)             | performs overload resolution while allowing boxing and unboxing. If no applicable method is found during this phase then processing continues to the third phase.<br><br>==in loose invocation it could be used  all  5 conversions that are used in method invocation contexts.==<br><br>identity conversion<br>Widening primitive conversion<br>Widening reference conversion<br>Boxing conversion optionally followed by widening reference<br>Unboxing conversion optionally followed by primitive reference                                                                                                                                                                                                                |
| variable arity invocation<br>(third phase)     | allows overloading to be combined with variable arity methods, boxing, and unboxing.<br><br>==all 5 conversion and  variable numbers arguments (var args)==                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| What are the fixed invocation                  | Strict invocation  and Loose invocation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Example<br><br>Case 1                          | step 1 => Determine type search<br><br>step 2 => Determine the method signature<br><br><br>step 2 => 1. Strict Invocation <br><br>find is there any methods that can be invoke without boxing and unboxing. <br><br>in here method with the argument type int is invoke using identity conversion. <br><br>![[Pasted image 20240216113647.png]]<br><br><br>gitHub link =><br>https://github.com/IJSE-Direct-Entry-Program-12/programming-fundamentals-5/blob/main/src/Demo27.java<br><br>                                                                                                                                                                                                                                       |
| Case 2                                         | ![[Pasted image 20240216113928.png]]<br>If there is no method with a int type parameters. method with the long type parameter will be invoked using the widening primitive conversion. <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| Case 3                                         | In here there is no method to overload under strict invocation. Then check is there any potential applicable methods to be overloaded under loos invocation.  <br><br>in here the method with the Integer type is invoked using the boxing conversions. <br><br>![[Pasted image 20240216114030.png]]<br><br><br><br>                                                                                                                                                                                                                                                                                                                                                                                                            |
| Case 4                                         | <br>In here boxing conversion optionally followed by widening reference conversion is used to determine invoke method.<br><br><br>![[Pasted image 20240216114105.png]]<br><br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| [[What is ambiguity in method overloading]]    | When there are more than one applicable methods to be invoked it is called  ambignity<br><br>In here compiler cannot decide the which method to be invoked. This is a example for a ambignity. <br><br>![[Pasted image 20240216114346.png]]<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                                | ![[Pasted image 20240216120944.png]]<br><br>Now Compiler can decide the which method to be envoked<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| [[How to determine a method from ambiguity]]   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
|                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
